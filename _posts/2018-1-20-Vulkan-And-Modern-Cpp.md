---
layout: post
date: 2018-01-25
title: "Abstracting the Vulkan API"
published: true
tags: [Programming, C++, Vulkan, Graphics, Libraries]
---

![Vulkan API Logo](https://www.amd.com/system/files/48981-vulkan-logo-1260x709.png)

Vulkan is a graphics API that one loves deeply, or quickly finds themselves hating. It's verbose, it's
unlike it's predecessor, and it has one hell of a learning curve. Abstracting much of it away can help, but one must avoid undoing what makes the API so great in the first place.

This post will be a bit of talk about the API itself, then a broad overview of the process and continued refinement that resulted in my proudest project yet. I'm not aiming just to feed my ego, however - I'm hoping this will help fill some of the void in the information about Vulkan.

Future posts will probably dive deeper into more specific design decisions and I made, and details about classes I created.

### Why use Vulkan?

There are so so many posts about this, so I'll avoid lingering on it. (Insert personal choice story)

### Raw API, or C++-friendly middlelayer?

The Vulkan API itself is C, through and through, and this is good for a bunch of reasons and bad for a bunch of reasons. The good includes:

- what you see is what you get, always
- enums can be bitmasked together
- C allows for other language bindings, yay C ABI!
- start at a zero overhead dead-simple interface 

The downsides, unsurprisingly, include:

- unscoped enums can feel cluttered, fast 
- also, holy enums. There are so many!
- Handles with no lifetime tracking or RAII

Nvidia tried to solve this with Vulkan-hpp, with the goal of lifetime tracking for handles, typesafe enums, and namespacing + classes + organizational tweaks. But I can sum up my feelings on that like so:

![Might be channeling Torvalds](https://i.imgur.com/2qNqF2Y.jpg)

It didnt feel right to me, because:

- lifetime tracking inevitably adds overhead, and this used a mechanism like `std::shared_ptr`

- typesafe enums are harder to `|` together or do other bitwise operations with 

- the organization felt off and unintuitive, and the code felt as autogenerated as it was.

Its not bad, and I already exist in a state of seething irritation with Nvidia so I'm biased anyways. But if one has the goal of abstracting Vulkan, why start with some of the work done already? (Or undone, ffs Nvidia..

### VulpesRender, and it's earliest iterations

Coming hot off a CUDA course and learning how to use OpenGL's direct state access, I was quite excited to use Vulkan. Compute capabilities were guaranteed, and above all else there wasn't any state tracking! 

But the first things a new user of Vulkan will encounter can scare them away just as quickly. Did you enjoy 2-3 lines of code to create a texture? Well, I hope you're ready to type literally as many as 100 lines of code to do the same in Vulkan.
